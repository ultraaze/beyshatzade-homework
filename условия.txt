Задача 1. Ветвистый if
1. Заведите две переменные типа int и занесите туда любые значения (особо продвинутые могут
считать аргументы запуска типа java Task1 42 34 . Конвертировать строку в число можно с
помощью функции Integer.valueOf )
2. Выведите на экран следующее:
- Если любое из чисел меньше нуля - надпись &quot;Есть  отрицательное число&quot;. Само число можно не
выводить
- Если второе число не ноль - надпись &quot;Результат деления:&quot; + результат деления первого, на
второе. Дробная часть не должна быть отброшена.
- Написать в консоли «Первое число больше второго» или «Второе число больше первого»…
- Если первое число четное - надпись &quot;число $ - четное&quot;.
 


Задача 2.  Массивные массивы
1. Заведите массив на 8 элементов типа int. Можете заполнить его самостоятельно или считать из
аргументов запуска (в этом случае, массив может быть любой длины)
2. Посчитайте сумму всех элементов. Выведите её на экран.
3. Если хотя бы одно число в массиве больше 1000 - выведите на экран надпись "Массив -
массивный!". Эта надпись должна быть выведена не больше одного раза, даже если чисел
больше 1000 несколько.
 


Задача 3. Есть массив чисел (см. предыдущее задание)
1. Найдите в нем самое больше число.
2. Если в массиве встретилось число 100500 - игнорировать его при определении самого
большого. Т.е.
в массиве [1, 2, 3, 100500, 42] - самое большое - 42.



Задача 4.
Все объекты должны находиться в package ru.mera.ваша фамилия.postman;
1.      Создать класс Person с полями name, surname
2.      Создать класс Message с полями from, to, message_body.
3.      Создать два подкласса Message: Email, Letter.
4.      В Email должны быть поля from, to, message_body, receive date.
5.      В Letter должны быть поля from (необязательное), to, message_body,   fromPostalIndex,
toPostalIndex
6.      Все классы выше должны быть immutable, т.е. не допускать изменения состояния после создания.
7.      Создайте класс MailBox в котором есть два массива для хранения сообщений – обычных и
электронных.
8.      В классе MailBox есть 4 метода: добавить сообщение обычное, электронное, получить все
обычные сообщения, получить все электронные сообщения.
9.      Массивы должны «вырастать», если емкость существующего массива заканчивается. Можете
использовать System.arrayCopy для этого
https://www.tutorialspoint.com/java/lang/system_arraycopy.htm



Задача 5. Приводимая неприводимость.
1. Создать класс Person с именем и фамилией. Переопределите метод toString, чтобы выводились
имя и фамилия.
2. Создать класс Artist (наследник Person) с дополнительным полем style - тип &quot;рисования&quot;
3. Создать класс Musician с дополнительным полем Instrument - инструмент на котором играет
музыкант.
Метод toString в классах Artist и musician не переопределяйте! 
4. Создать массив типа Person.
5. Положить туда несколько Музыкантов и Художников. (можно используя Random - класть
случайных людей, выбирая имена, фамилии, стили и инструменты из заранее определенного
списка)
6. Используя цикл for выведите на экран список всех людей в формате:
&quot;&lt;имя&gt; &lt;фамилия&gt; играет на &lt;instrument&gt;&quot;
или 
&quot;&lt;имя&gt; &lt;фамилия&gt; рисует в стиле  &lt;style&gt;&quot;
а зависимости от типа объекта (используйте instanceof, чтобы проверить)
 

 
Задача 6. Абстрактная конкретность.
Сегодня будем делать машину для приготовления коктейлей.
Рецепт - очень простой:
public void mix() {
        взятьЧтоТоЖидкое();
        взятьОсновнойИнгредиент();
        добавитьТопинг()
        print(&quot;Смешиваю %жидкое% с %наполнитель% и добавляю сверху %топинг%&quot;)
};
Вам нужно:
1. Сделать базовый абстрактный класс CocktailMaker с методом mix() и тремя абстрактными
методами для получения жидкого ингредиента, основного и топинга.
2.Создать несколько конкретных классов, которые всегда будут возвращать одни и те же
ингредиенты.
Например, BananaMilkCocktailMaker:
public String liquid {return &quot;Молоко&quot;}
public String mainIngredient {return &quot;Банан&quot;}
public String toping{return &quot;Мороженое&quot;}
3. Создать массив для базового класса и положить туда несколько разных машин для
приготовления коктейлей.
4. Запустить все машины по одному разу использую цикл for.



Задание 7. Продано!
Делаем интернет магазин.
В интернет магазине может хранится только 300 товаров максимум.
Есть товары. У каждого товара есть цена продажи, название, остаток на складе.
Некоторые товары можно вернуть после покупки. (интерфейс Returnable).
Если товар можно вернуть, то есть список необходимых документов для возврата.
 
Всего есть две  категорий товаров:
1. Электроинструменты. У каждого инструмента есть «потребляемая мощность»
- Пилы дисковые. У каждой пилы есть радиус режущего диска. Можно вернуть через 21 день.
Нужен чек и паспорт.
- Дрели. У каждой дрели есть максимальный диаметр сверла. Можно вернуть через 14 дней.
Нужен только чек.
-  Лобзики. У каждого лобзика есть максимальная толщина пропила. Нельзя вернуть.
 
2. Компьютеры. У каждого компьютера есть количество памяти, места на жестком диске и ядер
CPU.
- Ноутбук. Есть диагональ экрана и время работы без подзарядки. Можно вернуть через 14 дней.
Нужен чек и паспорт.
- Моноблок. Без дополнительных свойств.
 
1.      Создайте как минимум по два товара из каждой категории. (пила, дрель, лобзик, ноутбук,
моноблок)
2.      Выведите все товары  в формате.
Название Цена Количество + доп параметры для каждого конкретного товара. Например
Пила Bosch 6000 1шт радиус диска 140мм
Пила Зубр 3000 2шт радиус диска 240мм
…
3.      Выведите сумму, которую заработает магазин, продав все  товары.
4.      Для всех электроинструментов выведите предмет с наибольшей мощностью.
5.      Выведите сумму места на жестком диске для всех компьютеров.
6.      Выведите все товары, которые можно вернуть. Укажите, в течение скольких дней и какие
документы для этого нужны.
 
Рекомендации для выполнения:
1. Создайте интерфейс Item с методами getCount(), getName(), getQuantity()
2. Создайте интерфейс Returnable с методами getRequiredDocuments() , getDaysForReturn
3. Создайте абстрактный класс AbstractItem , реализующий интерфейс Item с полями count,name,
quantity.
4. Создайте абстрактные классы для Электроинсутрментов и компьютеров, наследующих
AbstractItem
5. Создайте конкретные классы для каждого товара. Где требуется  - реализуйте интерфейс
Returnable
6. Создайте массив на 300 элементов – это и есть ваш магазин.



Задание №8 Прятки
Есть 5 игроков и один ведущий. Каждый игрок может быть в трех состояниях: Спрятался,
Не спрятался, Ушел домой. У каждого игрока есть имя. Имена игроков не повторяются.
Ведущий пытается найти всех игроков. Он по очереди проверяет всех игроков.
Ведущий может:
- сказать «Не прячешься!» и указать на определенного игрока. 
Если игрок  не спрятался, то ведущий угадал его состояние и &quot;застучал&quot; –игрок
попадает в команду проигравших. Если игрок спрятался –игрок попадает в команду
победивших. 
- Сказать &quot;Прячешься!&quot; и указать на определенного игрока. 
Если игрок не прятался – то ведущий его не заметил и игрок застукивается за себя
и попадает в команду победивших.
Если игрок прятался, то он обязан выйти из укрытия, ведущий его находит и игрок
попадает в команду проигравших.
Если же игрок ушел домой, когда ему сказали &quot;Прячешься!&quot; – то это
исключительная ситуация MiJeDogovarivalisDomaNePryatatsaException и игра
завершается без победителей и проигравших.
Ваша задача:
1. Вывести список проигравших и список победивших.
2. В случае исключительной ситуации вывести надпись «&lt;имя игрока&gt; играет
нечестно»



Chat1
Написать консольного чат-бота, который на введённое пользователем предложение отвечает копией введённой фразы, 
но с удалёнными пробелами и верхним регистром. 
Так же пусть бот будет лишен эмоций и заменяет все восклицательные и вопросительные знаки на точки.
Если со времени последнего сообщения от пользователя прошло больше 3 часов, то бот добавляет фразу "чТОТОДАВНОТЕБЯНЕВИДНО".
При каждом новом запуске программы должна подгружаться история переписки.

Пример беседы:
12:30 Пользователь: Привет, друг, как дела !
12:30 Бот: ПРИВЕТ,ДРУГ,КАКДЕЛА.ЧТОТОДАВНОТЕБЯНЕВИДНО
12:33 Пользователь: Да..Весь в делах. Как сам ?
12:33 Бот: ДА..ВЕСЬВДЕЛАХ.КАКСАМ.




Chat2
Нужно теперь создать чат бота в два потока. Первый поток записывает введённые пользователем в консоли сообщения в файл. 
Второй поток - читает из файла, модифицирует сообщения по закону, описанному в предыдущем письме, выводит на консоль. 
Все остальные условия из задания Chat1.



PotokiVremeni
Ваша задача – сравнить производительность параллельной и последовательной записи.
У вас есть ArrayList со строками.
Положите туда не меньше 1000 строк.
Теперь вам нужно записать все строки в файлы.
Каждую строку запишите в отдельный файл. Название файла – индекс этой строки в листе (т.е.
1,2,3 и т.д.).
 
1. В папке strings_sequential запишите все строки, используя один поток.
2. В папке strings_parallel запишите все строки, использую по потоку на каждую строку.
3. Не забывайте закрывать потоки!
Измерьте время записи для каждого случая и выведите его на экран.
После этого вам нужно будет протестировать скорость чтения.
1. Прочитайте все файлы из strings_sequential и (используйте File.listFiles()) используя один поток.
Содержимое всех файлов положите в ArrayList с названием stringsSequential.
2. Прочитайте все файлы из strings_parallell используя по потоку на файлы. Содержимое всех файлов
положите в ArrayList с названием stringsParallel.
Измерьте время чтения для каждого случая и выведите его на экран.
Рекомендации.
1. С последовательным– все понятно: берем и читаем используя FileInputStream для чтения,
FileOutputStream для записи.
2. Для параллельного чтения вы можете использовать:
a. Класс Thread  и Runnable
b. ExecutorService
3. Во время параллельного чтения при добавлении в List у вас может возникнуть
ConcurrentModificationException – не забывайте про синхронизацию.
4. Порядок элементов во время чтения для параллельного и последовательного случая будет
различаться – это нормально в данной задаче.



MultiClientServerChat
Написать клиент-северное приложение для обмена сообщениями между пользователями (не общий чат, а между конкретными "друзьями").
Далее даю волю вашей фантазии. Клиент может быть как консольным, так и десктопным. Сервер пусть будет консольным.
Следующий сценарий должен работать. 
Боб послал сообщение Анне, хотя она не в сети. Анна получит сообщение, когда она появится в сети.
Если она выйдет в сеть с другого айпиадреса, она всё равно должна получить доступ к своей переписке, списку друзей.
